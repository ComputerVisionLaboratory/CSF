# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_csf.ipynb (unless otherwise specified).

__all__ = ['expand_dim_to_3', 'intensity_region_1', 'intensity_region_2', 'seperability_filter',
           'CircularSeparabilityFilter']

# Cell
import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np
import scipy.sparse
from tqdm import tqdm

from skimage.feature import peak_local_max

# Cell

#export

def expand_dim_to_3(arr):
    if arr.ndim == 2:
        return np.expand_dims(arr, axis=-1)
    elif arr.ndim == 3:
        return arr
    else:
        raise ValueError()


def intensity_region_1(img, cx, cy, r, return_pixels=False):
    width = img.shape[0]
    height = img.shape[1]
    mask = np.zeros((width, height), np.uint8)

    circle_img = cv.circle(mask,(cx,cy),r, (255,255,255), thickness=-1)
    masked_data = cv.bitwise_and(img, img, mask=circle_img)[cy-r:cy+r+1, cx-r:cx+r+1]

    masked_data = expand_dim_to_3(masked_data)
    pixels = masked_data[masked_data.sum(axis=2)!=0]
    n_pixels = len(pixels)

    if return_pixels:
        return pixels
    return pixels.mean(axis=0).mean(), n_pixels

def intensity_region_2(img, cx, cy, r_in, r_out, return_pixels=False):

    assert r_in < r_out
    width = img.shape[0]
    height = img.shape[1]
    mask_r_out, mask_r_in = np.zeros((width, height), np.uint8), np.zeros((width, height), np.uint8)

    mask_r_out = cv.circle(mask_r_out,(cx,cy),r_out, (255,255,255), thickness=-1)
    mask_r_in = cv.circle(mask_r_in,(cx,cy),r_in, (255,255,255), thickness=-1)
    mask = cv.bitwise_and(mask_r_out, mask_r_out, mask=cv.bitwise_not(mask_r_in))

    masked_data = cv.bitwise_and(img, img, mask=mask)
    masked_data = expand_dim_to_3(masked_data)

    pixels = masked_data[masked_data.sum(axis=2)!=0]
    n_pixels = len(pixels)
    if return_pixels:
        return pixels
    return pixels.mean(axis=0).mean(), n_pixels


def seperability_filter(img, r_in, r_out):
    width, height = img.shape[:2]
    result = np.zeros((width, height))

    for x in tqdm(range(r_out, width-r_out)):
        for y in range(r_out, height-r_out):

            r1_pixels = intensity_region_1(img, x, y, r_in, True)
            r2_pixels = intensity_region_2(img, x, y, r_in, r_out, True)
            if r1_pixels.size==0 or r2_pixels.size==0:
                result[x, y] = 0
                continue

            r1_mean = r1_pixels.mean(axis=0, keepdims=True).T
            r2_mean = r2_pixels.mean(axis=0, keepdims=True).T

            n_r1 = len(r1_pixels)
            n_r2 = len(r2_pixels)

            n_overall = n_r1 + n_r2
            overall_mean = r1_mean * n_r1/n_overall + r2_mean * n_r2/n_overall

            S_B = n_overall * (r1_mean - overall_mean).dot((r1_mean - overall_mean).T) + \
                n_overall * (r2_mean - overall_mean).dot((r2_mean - overall_mean).T)


            S_T = np.cov(np.concatenate([r1_pixels, r2_pixels]).T)
            if np.isnan(S_B).any() or np.isnan(S_T).any():
                result[x, y] = 0
            elif S_B.size==1:
                result[x,y] = S_B / S_T
            else:
                result[x,y] = np.trace(S_B) / np.trace(S_T)

    return result

# Cell

class CircularSeparabilityFilter:
    def __init__(self, r_in, r_out):
        self.r_in = r_in
        self.r_out = r_out

    def __call__(self, img):
        return seperability_filter(img, self.r_in, self.r_out)

    def find_circles(self, img, num_circles=None):
        sepmap = seperability_filter(img, self.r_in, self.r_out)
        sepmap[np.isnan(sepmap)]=0
        peaks = peak_local_max(sepmap)

        if num_circles is None:
            return peaks
        else:
            return peaks[:num_circles]
